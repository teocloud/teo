using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Encodings;
using System.Net.Http;

// Enumerable
namespace Teo {
    public struct Enumerable<T> {

        OneOf<T, T[]> _value;

        public OneOf<T, T[]> Value {
            get => _value;
            set {
                _value = value;
            }
        }

        public static implicit operator Enumerable<T>(OneOf<T, T[]> value) => new Enumerable<T> { Value = value };
        public static implicit operator Enumerable<T>(T t) => new Enumerable<T> { Value = (OneOf<T, T[]>)new Enumerable<T> { Value = t } };
        public static implicit operator Enumerable<T>(T[] a) => new Enumerable<T> { Value = (OneOf<T, T[]>)new Enumerable<T> { Value = a } };

        public static explicit operator OneOf<T, T[]>(Enumerable<T> enumerable) {
            return enumerable.Value;
        }

        public override string ToString() {
            return Value.ToString()!;
        }
    }
}

// Filters
namespace Teo {

    public class ComparableFilter<T> where T : struct {
        public new T? Equals { get; set; }
        public T[]? In { get; set; }
        public T[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, ComparableFilter<T>>? Not { get; set; }
        public ComparableFilter(
            T? equals = null,
            OneOf<T, ComparableFilter<T>>? not = null,
            T[]? @in = null,
            T[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
        }
    }

    public class ComparableNullableFilter<T> where T : struct {
        public new Optional<T>? Equals { get; set; }
        public T[]? In { get; set; }
        public T[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, ComparableNullableFilter<T>>? Not { get; set; }
        public ComparableNullableFilter(
            Optional<T>? equals = null,
            OneOf<T, ComparableNullableFilter<T>>? not = null,
            T[]? @in = null,
            T[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
        }
    }

    public class ComparableWithAggregatesFilter<T> where T : struct {
        public new T? Equals { get; set; }
        public T[]? In { get; set; }
        public T[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, ComparableWithAggregatesFilter<T>>? Not { get; set; }
        public ComparableFilter<int>? _Equals { get; set; }
        public ComparableFilter<T>? _Min { get; set; }
        public ComparableFilter<T>? _Max { get; set; }
        public ComparableWithAggregatesFilter(
            T? equals = null,
            OneOf<T, ComparableWithAggregatesFilter<T>>? not = null,
            T[]? @in = null,
            T[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null,
            ComparableFilter<int>? _equals = null,
            ComparableFilter<T>? _min = null,
            ComparableFilter<T>? _max = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            _Equals = _equals;
            _Min = _min;
            _Max = _max;
        }
    }

    public class ComparableNullableWithAggregatesFilter<T> where T : struct {
        public new Optional<T>? Equals { get; set; }
        public Optional<T>[]? In { get; set; }
        public Optional<T>[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, ComparableNullableWithAggregatesFilter<T>>? Not { get; set; }
        public ComparableNullableFilter<int>? _Equals { get; set; }
        public ComparableNullableFilter<T>? _Min { get; set; }
        public ComparableNullableFilter<T>? _Max { get; set; }
        public ComparableNullableWithAggregatesFilter(
            Optional<T>? equals = null,
            OneOf<T, ComparableNullableWithAggregatesFilter<T>>? not = null,
            Optional<T>[]? @in = null,
            Optional<T>[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null,
            ComparableNullableFilter<int>? _equals = null,
            ComparableNullableFilter<T>? _min = null,
            ComparableNullableFilter<T>? _max = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            _Equals = _equals;
            _Min = _min;
            _Max = _max;
        }
    }

    public class NumberWithAggregatesFilter<T> : ComparableWithAggregatesFilter<T> where T : struct {
        public new OneOf<T, NumberWithAggregatesFilter<T>>? Not { get; set; }
        public ComparableFilter<T>? _Sum { get; set; }
        public ComparableFilter<double>? _Avg { get; set; }
        public NumberWithAggregatesFilter(
            T? equals = null,
            OneOf<T, NumberWithAggregatesFilter<T>>? not = null,
            T[]? @in = null,
            T[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null,
            ComparableFilter<int>? _equals = null,
            ComparableFilter<T>? _min = null,
            ComparableFilter<T>? _max = null,
            ComparableFilter<T>? _sum = null,
            ComparableFilter<double>? _avg = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            _Equals = _equals;
            _Min = _min;
            _Max = _max;
            _Sum = _sum;
            _Avg = _avg;
        }
    }

    public class NumberNullableWithAggregatesFilter<T> : ComparableNullableWithAggregatesFilter<T> where T : struct {
        public new OneOf<T, NumberNullableWithAggregatesFilter<T>>? Not { get; set; }
        public ComparableNullableFilter<T>? _Sum { get; set; }
        public ComparableNullableFilter<double>? _Avg { get; set; }
        public NumberNullableWithAggregatesFilter(
            Optional<T>? equals = null,
            OneOf<T, NumberNullableWithAggregatesFilter<T>>? not = null,
            Optional<T>[]? @in = null,
            Optional<T>[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null,
            ComparableNullableFilter<int>? _equals = null,
            ComparableNullableFilter<T>? _min = null,
            ComparableNullableFilter<T>? _max = null,
            ComparableNullableFilter<T>? _sum = null,
            ComparableNullableFilter<double>? _avg = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            _Equals = _equals;
            _Min = _min;
            _Max = _max;
            _Sum = _sum;
            _Avg = _avg;
        }
    }

    public class RefComparableFilter<T> where T : class {
        public new T? Equals { get; set; }
        public T[]? In { get; set; }
        public T[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, RefComparableFilter<T>>? Not { get; set; }
        public RefComparableFilter(
            T? equals = null,
            OneOf<T, RefComparableFilter<T>>? not = null,
            T[]? @in = null,
            T[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
        }
    }

    public class RefComparableNullableFilter<T> where T : class {
        public new Optional<T>? Equals { get; set; }
        public Optional<T>[]? In { get; set; }
        public Optional<T>[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<Optional<T>, RefComparableNullableFilter<T>>? Not { get; set; }
        public RefComparableNullableFilter(
            Optional<T>? equals = null,
            OneOf<Optional<T>, RefComparableNullableFilter<T>>? not = null,
            Optional<T>[]? @in = null,
            Optional<T>[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
        }
    }

    public class RefComparableWithAggregatesFilter<T> where T : class {
        public new T? Equals { get; set; }
        public T[]? In { get; set; }
        public T[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, RefComparableWithAggregatesFilter<T>>? Not { get; set; }
        public ComparableFilter<int>? _Count { get; set; }
        public RefComparableFilter<T>? _Min { get; set; }
        public RefComparableFilter<T>? _Max { get; set; }
        public RefComparableWithAggregatesFilter(
            T? equals = null,
            OneOf<T, RefComparableWithAggregatesFilter<T>>? not = null,
            T[]? @in = null,
            T[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null,
            ComparableFilter<int>? _count = null,
            RefComparableFilter<T>? _min = null,
            RefComparableFilter<T>? _max = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            _Count = _count;
            _Min = _min;
            _Max = _max;
        }
    }

    public class RefComparableNullableWithAggregatesFilter<T> where T : class {
        public new Optional<T>? Equals { get; set; }
        public Optional<T>[]? In { get; set; }
        public Optional<T>[]? NotIn { get; set; }
        public T? Lt { get; set; }
        public T? Lte { get; set; }
        public T? Gt { get; set; }
        public T? Gte { get; set; }
        public OneOf<T, RefComparableNullableWithAggregatesFilter<T>>? Not { get; set; }
        public ComparableNullableFilter<int>? _Count { get; set; }
        public RefComparableNullableFilter<T>? _Min { get; set; }
        public RefComparableNullableFilter<T>? _Max { get; set; }
        public RefComparableNullableWithAggregatesFilter(
            Optional<T>? equals = null,
            OneOf<T, RefComparableNullableWithAggregatesFilter<T>>? not = null,
            Optional<T>[]? @in = null,
            Optional<T>[]? notIn = null,
            T? lt = null,
            T? lte = null,
            T? gt = null,
            T? gte = null,
            ComparableNullableFilter<int>? _count = null,
            RefComparableNullableFilter<T>? _min = null,
            RefComparableNullableFilter<T>? _max = null
        ) {
            Equals = equals;
            Not = not;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            _Count = _count;
            _Min = _min;
            _Max = _max;
        }
    }

    public class BoolFilter {
        public new bool? Equals { get; set; }
        public OneOf<bool, BoolFilter>? Not { get; set; }
        public BoolFilter(bool? equals = null, OneOf<bool, BoolFilter>? not = null) {
            Equals = equals;
            Not = not;
        }
    }

    public class BoolNullableFilter {
        public new Optional<bool>? Equals { get; set; }
        public OneOf<Optional<bool>, BoolNullableFilter>? Not { get; set; }
        public BoolNullableFilter(Optional<bool>? equals = null, OneOf<Optional<bool>, BoolNullableFilter>? not = null) {
            Equals = equals;
            Not = not;
        }
    }

    public class BoolWithAggregatesFilter {
        public new bool? Equals { get; set; }
        public OneOf<bool, BoolWithAggregatesFilter>? Not { get; set; }
        public ComparableFilter<int>? _Count { get; set; }
        public BoolFilter? _Min { get; set; }
        public BoolFilter? _Max { get; set; }
        public BoolWithAggregatesFilter(
            bool? equals = null,
            OneOf<bool, BoolWithAggregatesFilter>? not = null,
            ComparableFilter<int>? _count = null,
            BoolFilter? _min = null,
            BoolFilter? _max = null
        ) {
            Equals = equals;
            Not = not;
            _Count = _count;
            _Min = _min;
            _Max = _max;
        }
    }

    public class BoolNullableWithAggregatesFilter {
        public new Optional<bool>? Equals { get; set; }
        public OneOf<bool, BoolNullableWithAggregatesFilter>? Not { get; set; }
        public ComparableNullableFilter<int>? _Count { get; set; }
        public BoolNullableFilter? _Min { get; set; }
        public BoolNullableFilter? _Max { get; set; }
        public BoolNullableWithAggregatesFilter(
            bool? equals = null,
            OneOf<bool, BoolNullableWithAggregatesFilter>? not = null,
            ComparableNullableFilter<int>? _count = null,
            BoolNullableFilter? _min = null,
            BoolNullableFilter? _max = null
        ) {
            Equals = equals;
            Not = not;
            _Count = _count;
            _Min = _min;
            _Max = _max;
        }
    }

    public class StringFilter : RefComparableFilter<string> {
        public string? Contains { get; set; }
        public string? StartsWith { get; set; }
        public string? EndsWith { get; set; }
        public string? Matches { get; set; }
        public new OneOf<string, StringFilter>? Not { get; set; }
        public StringFilter(
            string? equals = null,
            string[]? @in = null,
            string[]? notIn = null,
            string? lt = null,
            string? lte = null,
            string? gt = null,
            string? gte = null,
            string? contains = null,
            string? startsWith = null,
            string? endsWith = null,
            string? matches = null,
            OneOf<string, StringFilter>? not = null
        ) {
            Equals = equals;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            Contains = contains;
            StartsWith = startsWith;
            EndsWith = endsWith;
            Matches = matches;
            Not = not;
        }
    }

    public class StringNullableFilter : RefComparableNullableFilter<string> {
        public string? Contains { get; set; }
        public string? StartsWith { get; set; }
        public string? EndsWith { get; set; }
        public string? Matches { get; set; }
        public new OneOf<Optional<string>, StringNullableFilter>? Not { get; set; }
        public StringNullableFilter(
            Optional<string>? equals = null,
            Optional<string>[]? @in = null,
            Optional<string>[]? notIn = null,
            string? lt = null,
            string? lte = null,
            string? gt = null,
            string? gte = null,
            string? contains = null,
            string? startsWith = null,
            string? endsWith = null,
            string? matches = null,
            OneOf<Optional<string>, StringNullableFilter>? not = null
        ) {
            Equals = equals;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            Contains = contains;
            StartsWith = startsWith;
            EndsWith = endsWith;
            Matches = matches;
            Not = not;
        }
    }

    public class StringWithAggregatesFilter : RefComparableWithAggregatesFilter<string> {
        public string? Contains { get; set; }
        public string? StartsWith { get; set; }
        public string? EndsWith { get; set; }
        public string? Matches { get; set; }
        public new OneOf<string, StringWithAggregatesFilter>? Not { get; set; }
        public new StringFilter? _Min { get; set; }
        public new StringFilter? _Max { get; set; }
        public StringWithAggregatesFilter(
            string? equals = null,
            string[]? @in = null,
            string[]? notIn = null,
            string? lt = null,
            string? lte = null,
            string? gt = null,
            string? gte = null,
            string? contains = null,
            string? startsWith = null,
            string? endsWith = null,
            string? matches = null,
            OneOf<string, StringWithAggregatesFilter>? not = null,
            ComparableFilter<int>? _count = null,
            StringFilter? _min = null,
            StringFilter? _max = null
        ) {
            Equals = equals;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            Contains = contains;
            StartsWith = startsWith;
            EndsWith = endsWith;
            Matches = matches;
            Not = not;
            _Count = _count;
            _Min = _min;
            _Max = _max;
        }
    }

    public class StringNullableWithAggregatesFilter : RefComparableNullableWithAggregatesFilter<string> {
        public string? Contains { get; set; }
        public string? StartsWith { get; set; }
        public string? EndsWith { get; set; }
        public string? Matches { get; set; }
        public new OneOf<string, StringNullableWithAggregatesFilter>? Not { get; set; }
        public new StringNullableFilter? _Min { get; set; }
        public new StringNullableFilter? _Max { get; set; }
        public StringNullableWithAggregatesFilter(
            Optional<string>? equals = null,
            Optional<string>[]? @in = null,
            Optional<string>[]? notIn = null,
            string? lt = null,
            string? lte = null,
            string? gt = null,
            string? gte = null,
            string? contains = null,
            string? startsWith = null,
            string? endsWith = null,
            string? matches = null,
            OneOf<string, StringNullableWithAggregatesFilter>? not = null,
            ComparableNullableFilter<int>? _count = null,
            StringNullableFilter? _min = null,
            StringNullableFilter? _max = null
        ) {
            Equals = equals;
            In = @in;
            NotIn = notIn;
            Lt = lt;
            Lte = lte;
            Gt = gt;
            Gte = gte;
            Contains = contains;
            StartsWith = startsWith;
            EndsWith = endsWith;
            Matches = matches;
            Not = not;
            _Count = _count;
            _Min = _min;
            _Max = _max;
        }
    }

    public class EnumFilter<T> where T : struct {
        public new T? Equals { get; set; }
        public T[]? In { get; set; }
        public T[]? NotIn { get; set; }
        public OneOf<T, EnumFilter<T>>? Not { get; set; }
        public EnumFilter(
            T? equals,
            T[]? @in,
            T[]? notIn,
            OneOf<T, EnumFilter<T>>? not
        ) {
            Equals = equals;
            In = @in;
            NotIn = notIn;
            Not = not;
        }
    }

    public class EnumNullableFilter<T> where T : struct {
        public new Optional<T>? Equals { get; set; }
        public Optional<T>[]? In { get; set; }
        public Optional<T>[]? NotIn { get; set; }
        public OneOf<Optional<T>, EnumNullableFilter<T>>? Not { get; set; }
        public EnumNullableFilter(
            Optional<T>? equals,
            Optional<T>[]? @in,
            Optional<T>[]? notIn,
            OneOf<Optional<T>, EnumNullableFilter<T>>? not
        ) {
            Equals = equals;
            In = @in;
            NotIn = notIn;
            Not = not;
        }
    }

    public class ValueArrayFilter<T> where T : struct {
        public new T? Equals { set; get; }
        public T? Has { set; get; }
        public T[]? HasSome { set; get; }
        public T[]? HasEvery { set; get; }
        public bool? IsEmpty { get; set; }
        public int? Length { get; set; }

        public ValueArrayFilter(
            T? equals = null,
            T? has = null,
            T[]? hasSome = null,
            T[]? hasEvery = null,
            bool? isEmpty = null,
            int? length = null
        ) {
            Equals = equals;
            Has = has;
            HasSome = hasSome;
            HasEvery = hasEvery;
            IsEmpty = isEmpty;
            Length = length;
        }
    }

    public class ValueArrayNullableFilter<T> where T : struct {
        public new Optional<T>? Equals { set; get; }
        public T? Has { set; get; }
        public T[]? HasSome { set; get; }
        public T[]? HasEvery { set; get; }
        public bool? IsEmpty { get; set; }
        public int? Length { get; set; }

        public ValueArrayNullableFilter(
            Optional<T>? equals = null,
            T? has = null,
            T[]? hasSome = null,
            T[]? hasEvery = null,
            bool? isEmpty = null,
            int? length = null
        ) {
            Equals = equals;
            Has = has;
            HasSome = hasSome;
            HasEvery = hasEvery;
            IsEmpty = isEmpty;
            Length = length;
        }
    }

    public class RefArrayFilter<T> where T : class {
        public new T? Equals { set; get; }
        public T? Has { set; get; }
        public T[]? HasSome { set; get; }
        public T[]? HasEvery { set; get; }
        public bool? IsEmpty { get; set; }
        public int? Length { get; set; }

        public RefArrayFilter(
            T? equals = null,
            T? has = null,
            T[]? hasSome = null,
            T[]? hasEvery = null,
            bool? isEmpty = null,
            int? length = null
        ) {
            Equals = equals;
            Has = has;
            HasSome = hasSome;
            HasEvery = hasEvery;
            IsEmpty = isEmpty;
            Length = length;
        }
    }

    public class RefArrayNullableFilter<T> where T : class {
        public new Optional<T>? Equals { set; get; }
        public T? Has { set; get; }
        public T[]? HasSome { set; get; }
        public T[]? HasEvery { set; get; }
        public bool? IsEmpty { get; set; }
        public int? Length { get; set; }

        public RefArrayNullableFilter(
            Optional<T>? equals = null,
            T? has = null,
            T[]? hasSome = null,
            T[]? hasEvery = null,
            bool? isEmpty = null,
            int? length = null
        ) {
            Equals = equals;
            Has = has;
            HasSome = hasSome;
            HasEvery = hasEvery;
            IsEmpty = isEmpty;
            Length = length;
        }
    }
}

// One of
#nullable disable
namespace Teo {

    public interface IOneOf {
        object Value { get; }
        int Index { get; }
    }

    internal static class Functions {
        internal static string FormatValue<T>(T value) => $"{typeof(T).FullName}: {value?.ToString()}";
        internal static string FormatValue<T>(object @this, object @base, T value) =>
            ReferenceEquals(@this, value) ?
                @base.ToString() :
                $"{typeof(T).FullName}: {value?.ToString()}";
    }

    public struct OneOf<T0, T1> : IOneOf {
        readonly T0 _value0;
        readonly T1 _value1;
        readonly int _index;

        OneOf(int index, T0 value0 = default, T1 value1 = default) {
            _index = index;
            _value0 = value0;
            _value1 = value1;
        }

        public object Value =>
            _index switch {
                0 => _value0,
                1 => _value1,
                _ => throw new InvalidOperationException()
            };

        public int Index => _index;

        public bool IsT0 => _index == 0;
        public bool IsT1 => _index == 1;

        public T0 AsT0 =>
            _index == 0 ?
                _value0 :
                throw new InvalidOperationException($"Cannot return as T0 as result is T{_index}");
        public T1 AsT1 =>
            _index == 1 ?
                _value1 :
                throw new InvalidOperationException($"Cannot return as T1 as result is T{_index}");

        public static implicit operator OneOf<T0, T1>(T0 t) => new OneOf<T0, T1>(0, value0: t);
        public static implicit operator OneOf<T0, T1>(T1 t) => new OneOf<T0, T1>(1, value1: t);

        public void Switch(Action<T0> f0, Action<T1> f1) {
            if (_index == 0 && f0 != null) {
                f0(_value0);
                return;
            }
            if (_index == 1 && f1 != null) {
                f1(_value1);
                return;
            }
            throw new InvalidOperationException();
        }

        public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1) {
            if (_index == 0 && f0 != null) {
                return f0(_value0);
            }
            if (_index == 1 && f1 != null) {
                return f1(_value1);
            }
            throw new InvalidOperationException();
        }

        public static OneOf<T0, T1> FromT0(T0 input) => input;
        public static OneOf<T0, T1> FromT1(T1 input) => input;


        public OneOf<TResult, T1> MapT0<TResult>(Func<T0, TResult> mapFunc) {
            if (mapFunc == null) {
                throw new ArgumentNullException(nameof(mapFunc));
            }
            return _index switch {
                0 => mapFunc(AsT0),
                1 => AsT1,
                _ => throw new InvalidOperationException()
            };
        }

        public OneOf<T0, TResult> MapT1<TResult>(Func<T1, TResult> mapFunc) {
            if (mapFunc == null) {
                throw new ArgumentNullException(nameof(mapFunc));
            }
            return _index switch {
                0 => AsT0,
                1 => mapFunc(AsT1),
                _ => throw new InvalidOperationException()
            };
        }

        public bool TryPickT0(out T0 value, out T1 remainder) {
            value = IsT0 ? AsT0 : default;
            remainder = _index switch {
                0 => default,
                1 => AsT1,
                _ => throw new InvalidOperationException()
            };
            return this.IsT0;
        }

        public bool TryPickT1(out T1 value, out T0 remainder) {
            value = IsT1 ? AsT1 : default;
            remainder = _index switch {
                0 => AsT0,
                1 => default,
                _ => throw new InvalidOperationException()
            };
            return this.IsT1;
        }

        bool Equals(OneOf<T0, T1> other) =>
            _index == other._index &&
            _index switch {
                0 => Equals(_value0, other._value0),
                1 => Equals(_value1, other._value1),
                _ => false
            };

        public override bool Equals(object obj) {
            if (ReferenceEquals(null, obj)) {
                return false;
            }

            return obj is OneOf<T0, T1> o && Equals(o);
        }

        public override string ToString() =>
            _index switch {
                0 => Functions.FormatValue(_value0),
                1 => Functions.FormatValue(_value1),
                _ => throw new InvalidOperationException("Unexpected index, which indicates a problem in the OneOf codegen.")
            };

        public override int GetHashCode() {
            unchecked {
                int hashCode = _index switch {
                    0 => _value0?.GetHashCode(),
                    1 => _value1?.GetHashCode(),
                    _ => 0
                } ?? 0;
                return (hashCode * 397) ^ _index;
            }
        }
    }
}

// Operations
#nullable enable
namespace Teo {
    public class ObjectIdFieldUpdateOperationsInput {
        public string? Set { get; set; }
        public ObjectIdFieldUpdateOperationsInput(string? set) { Set = set; }
    }

    public class NullableObjectIdFieldUpdateOperationsInput {
        public Optional<string>? Set { get; set; }
        public NullableObjectIdFieldUpdateOperationsInput(Optional<string>? set) { Set = set; }
    }

    public class StringFieldUpdateOperationsInput {
        public string? Set { get; set; }
        public StringFieldUpdateOperationsInput(string? set) { Set = set; }
    }

    public class NullableStringFieldUpdateOperationsInput {
        public Optional<string>? Set { get; set; }
        public NullableStringFieldUpdateOperationsInput(Optional<string>? set) { Set = set; }
    }

    public class NumberFieldUpdateOperationsInput<T> where T: struct {
        public T? Set { get; set; }
        public T? Increment { get; set; }
        public T? Decrement { get; set; }
        public T? Multiply { get; set; }
        public T? Divide { get; set; }
        public NumberFieldUpdateOperationsInput(
            T? set = null,
            T? increment = null,
            T? decrement = null,
            T? multiply = null,
            T? divide = null
        ) {
            Set = set;
            Increment = increment;
            Decrement = decrement;
            Multiply = multiply;
            Divide = divide;
        }
    }

    public class NullableNumberFieldUpdateOperationsInput<T> where T : struct {
        public Optional<T>? Set { get; set; }
        public T? Increment { get; set; }
        public T? Decrement { get; set; }
        public T? Multiply { get; set; }
        public T? Divide { get; set; }
        public NullableNumberFieldUpdateOperationsInput(
            Optional<T>? set = null,
            T? increment = null,
            T? decrement = null,
            T? multiply = null,
            T? divide = null
        ) {
            Set = set;
            Increment = increment;
            Decrement = decrement;
            Multiply = multiply;
            Divide = divide;
        }
    }

    public class BoolFieldUpdateOperationsInput {
        public bool? Set { get; set; }
        public BoolFieldUpdateOperationsInput(bool? set) { Set = set; }
    }

    public class NullableBoolFieldUpdateOperationsInput {
        public Optional<bool>? Set { get; set; }
        public NullableBoolFieldUpdateOperationsInput(Optional<bool>? set) { Set = set; }
    }

    public class DateOnlyFieldUpdateOperationsInput {
        public DateOnly? Set { get; set; }
        public DateOnlyFieldUpdateOperationsInput(DateOnly? set) { Set = set; }
    }

    public class NullableDateOnlyFieldUpdateOperationsInput {
        public Optional<DateOnly>? Set { get; set; }
        public NullableDateOnlyFieldUpdateOperationsInput(Optional<DateOnly>? set) { Set = set; }
    }

    public class DateTimeFieldUpdateOperationsInput {
        public DateTime? Set { get; set; }
        public DateTimeFieldUpdateOperationsInput(DateTime? set) { Set = set; }
    }

    public class NullableDateTimeFieldUpdateOperationsInput {
        public Optional<DateTime>? Set { get; set; }
        public NullableDateTimeFieldUpdateOperationsInput(Optional<DateTime>? set) { Set = set; }
    }

    public class EnumFieldUpdateOperationsInput<T> where T: struct {
        public T? Set { get; set; }
        public EnumFieldUpdateOperationsInput(T? set) { Set = set; }
    }

    public class NullableEnumFieldUpdateOperationsInput<T> where T : struct {
        public Optional<T>? Set { get; set; }
        public NullableEnumFieldUpdateOperationsInput(Optional<T>? set) { Set = set; }
    }

    public class ValueArrayFieldUpdateOperationsInput<T> where T : struct {
        public T[]? Set { get; set; }
        public T? Push { get; set; }
        public ValueArrayFieldUpdateOperationsInput(T[]? set = null, T? push = null) {
            Set = set;
            Push = push;
        }
    }

    public class NullableValueArrayFieldUpdateOperationsInput<T> where T : struct {
        public Optional<T[]>? Set { get; set; }
        public T? Push { get; set; }
        public NullableValueArrayFieldUpdateOperationsInput(Optional<T[]>? set = null, T? push = null) {
            Set = set;
            Push = push;
        }
    }

    public class RefArrayFieldUpdateOperationsInput<T> where T : class {
        public T[]? Set { get; set; }
        public T? Push { get; set; }
        public RefArrayFieldUpdateOperationsInput(T[]? set = null, T? push = null) {
            Set = set;
            Push = push;
        }
    }

    public class NullableRefArrayFieldUpdateOperationsInput<T> where T : class {
        public Optional<T[]>? Set { get; set; }
        public T? Push { get; set; }
        public NullableRefArrayFieldUpdateOperationsInput(Optional<T[]>? set = null, T? push = null) {
            Set = set;
            Push = push;
        }
    }
}

// Optional
namespace Teo {

    public class Null {
        public Null() { }

        public static readonly Null NULL = new();

        public override string ToString() => "Null";
    }

    public struct Optional<T> {
        OneOf<T, Null> _value;

        public OneOf<T, Null> Value {
            get => _value;
            set {
                _value = value;
            }
        }

        public static implicit operator Optional<T>(OneOf<T, Null> value) => new Optional<T> { Value = value };
        public static implicit operator Optional<T>(T t) => new Optional<T> { Value = (OneOf<T, Null>)new Optional<T> { Value = t } };
        public static implicit operator Optional<T>(Null n) => new Optional<T> { Value = (OneOf<T, Null>)new Optional<T> { Value = n } };

        public static explicit operator OneOf<T, Null>(Optional<T> optional) {
            return optional.Value;
        }

        public override string ToString() {
            return Value.ToString()!;
        }
    }
}

// Sort order
namespace Teo {
    public enum SortOrder {
        Asc,
        Desc,
    }
}

// Resp
namespace Teo {
    public struct Response<D> {
        public D Data { get; set; }
    }

    public struct Response<M, D> {
        public M Meta { get; set; }
        public D Data { get; set; }
    }

    public struct ResponseError {
        public string Type { get; set; }
        public string Message { get; set; }
        public Dictionary<string, string>? Errors { get; set; }
    }

    public struct PagingInfo {
        public uint Count { get; set; }
        public uint? NumberOfPages { get; set; }
    }

    public struct TokenInfo {
        public string Token { get; set; }
    }

    public class TeoException : Exception {

        public override string Message { get; }

        public string Type { get; }

        public Dictionary<string, string>? Errors { get; }

        public TeoException(ResponseError responseError) {
            Message = responseError.Message;
            Type = responseError.Type;
            Errors = responseError.Errors;
        }
    }
}

#nullable enable
namespace Teo {
{%- for class in outline.classes %}
    {%- if class.kind.is_any_kind_of_enum() %}
    public enum {{ class.name() }} {
        {%- for field in class.fields %}
        {{ field.name|pascalcase }} = {{ loop.index }},
        {%- endfor %}
    }
    {%- else %}
    public class {{ class.model_name }}{{ class.name_suffix }} {
        {%- for field in class.fields_optional_at_last() %}
        public {{ field.field_type }}{%- if field.optional || class.kind.is_output() %}?{%- endif %} {{ field.name|capitalize_first }} { get; set; }
        {%- endfor %}
        public {{ class.model_name }}{{ class.name_suffix }}(
        {%- for field in class.fields_optional_at_last() %}
            {{ field.field_type }}{%- if field.optional || class.kind.is_output() %}?{%- endif %} {{ field.name|escape_csharp }}{%- if field.optional || class.kind.is_output() %} = null{%- endif %}{% if !loop.last %},{% endif %}
        {%- endfor %}
        ) {
        {%- for field in class.fields_optional_at_last() %}
            {{ field.name|capitalize_first }} = {{ field.name|escape_csharp }};
        {%- endfor %}
        }
    }
    {%- endif %}
{%- endfor %}

    // Serializers
    public class DateOnlyConverter : JsonConverter<DateOnly> {
        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            return DateOnly.Parse(reader.GetString() ?? string.Empty);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options) {
            writer.WriteStringValue(value.ToString("yyyy-MM-dd"));
        }
    }

    public class DateTimeConverter : JsonConverter<DateTime> {
        public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            return DateTime.Parse(reader.GetString() ?? string.Empty);
        }

        public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options) {
            writer.WriteStringValue(value.ToString("yyyy-MM-ddTHH:mm:ss.fffK"));
        }
    }

    public class DateTimeOffsetConverter : JsonConverter<DateTimeOffset> {
        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            return DateTimeOffset.Parse(reader.GetString() ?? string.Empty);
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options) {
            writer.WriteStringValue(value.UtcDateTime.ToString("yyyy-MM-ddTHH:mm:ss.fffK"));
        }
    }

    public class OneOfJsonConverterFactory : JsonConverterFactory {
        public override bool CanConvert(Type typeToConvert) {
            if (!typeToConvert.IsGenericType) {
                return false;
            }
            if (typeToConvert.GetGenericTypeDefinition() != typeof(OneOf<,>)) {
                return false;
            }
            return true;
        }

        public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options) {
            Type t0 = typeToConvert.GetGenericArguments()[0];
            Type t1 = typeToConvert.GetGenericArguments()[1];

            JsonConverter converter = (JsonConverter)Activator.CreateInstance(
                typeof(OneOfJsonConverter<,>).MakeGenericType(new Type[] { t0, t1 }),
                BindingFlags.Instance | BindingFlags.Public,
                binder: null,
                args: null,
                culture: null)!;

            return converter;
        }
    }

    public class OneOfJsonConverter<T0, T1> : JsonConverter<OneOf<T0, T1>> {

        public override OneOf<T0, T1> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            throw new NotImplementedException();
        }

        public override void Write(Utf8JsonWriter writer, OneOf<T0, T1> value, JsonSerializerOptions options) {
            value.Switch(
                t0 => { writer.WriteRawValue(JSJsonSerializer.Serialize(t0)); },
                t1 => { writer.WriteRawValue(JSJsonSerializer.Serialize(t1)); });
        }
    }

    public class OptionalJsonConverterFactory : JsonConverterFactory {

        public override bool CanConvert(Type typeToConvert) {
            if (!typeToConvert.IsGenericType) {
                return false;
            }
            if (typeToConvert.GetGenericTypeDefinition() != typeof(Optional<>)) {
                return false;
            }
            return true;
        }

        public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options) {
            Type t0 = typeToConvert.GetGenericArguments()[0];

            JsonConverter converter = (JsonConverter)Activator.CreateInstance(
                typeof(OptionalJsonConverter<>).MakeGenericType(new Type[] { t0 }),
                BindingFlags.Instance | BindingFlags.Public,
                binder: null,
                args: null,
                culture: null)!;

            return converter;
        }
    }

    public class OptionalJsonConverter<T> : JsonConverter<Optional<T>> {

        public override Optional<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            throw new NotImplementedException();
        }

        public override void Write(Utf8JsonWriter writer, Optional<T> value, JsonSerializerOptions options) {
            value.Value.Switch(
                t0 => writer.WriteRawValue(JSJsonSerializer.Serialize(value.Value.AsT0)),
                t1 => writer.WriteRawValue("null"));
        }
    }

    public class EnumerableJsonConverterFactory : JsonConverterFactory {

        public override bool CanConvert(Type typeToConvert) {
            if (!typeToConvert.IsGenericType) {
                return false;
            }
            if (typeToConvert.GetGenericTypeDefinition() != typeof(Enumerable<>)) {
                return false;
            }
            return true;
        }

        public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options) {
            Type t0 = typeToConvert.GetGenericArguments()[0];

            JsonConverter converter = (JsonConverter)Activator.CreateInstance(
                typeof(EnumerableJsonConverter<>).MakeGenericType(new Type[] { t0 }),
                BindingFlags.Instance | BindingFlags.Public,
                binder: null,
                args: null,
                culture: null)!;

            return converter;
        }
    }

    public class EnumerableJsonConverter<T> : JsonConverter<Enumerable<T>> {

        public override Enumerable<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            throw new NotImplementedException();
        }

        public override void Write(Utf8JsonWriter writer, Enumerable<T> value, JsonSerializerOptions options) {
            value.Value.Switch(
                t0 => writer.WriteRawValue(JSJsonSerializer.Serialize(value.Value.AsT0)),
                t1 => writer.WriteRawValue(JSJsonSerializer.Serialize(value.Value.AsT1)));
        }
    }

    public class SortOrderJsonConverter: JsonConverter<SortOrder> {
        public override SortOrder Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            throw new NotImplementedException();
        }

        public override void Write(Utf8JsonWriter writer, SortOrder value, JsonSerializerOptions options) {
            switch (value) {
                case SortOrder.Asc: {
                    writer.WriteStringValue("asc");
                    return;
                }
                case SortOrder.Desc: {
                    writer.WriteStringValue("desc");
                    return;
                }
            }
        }
    }

{%- for class in outline.classes %}
    {%- if class.kind.is_any_kind_of_enum() %}
    public class {{ class.name() }}JsonConverter : JsonConverter<{{ class.name() }}> {
        public override {{ class.name() }} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            switch (reader.GetString()) {
        {%- for field in class.fields %}
                case "{{ field.name }}": {
                    return {{ class.name() }}.{{ field.name|pascalcase}};
                }
        {%- endfor %}
            }
            throw new NotImplementedException();
        }
        public override void Write(Utf8JsonWriter writer, {{ class.name() }} value, JsonSerializerOptions options) {
            switch (value) {
        {%- for field in class.fields %}
                case {{ class.name() }}.{{ field.name|pascalcase}}: {
                    writer.WriteStringValue("{{ field.name }}");
                    return;
               }
        {%- endfor %}
            }
        }
    }
    {%- endif %}
{%- endfor %}

    static public class JSJsonSerializer {
        static private JsonSerializerOptions options() {
            var options = new JsonSerializerOptions {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
            };
            options.Converters.Add(new DateOnlyConverter());
            options.Converters.Add(new DateTimeConverter());
            options.Converters.Add(new DateTimeOffsetConverter());
            options.Converters.Add(new OneOfJsonConverterFactory());
            options.Converters.Add(new OptionalJsonConverterFactory());
            options.Converters.Add(new EnumerableJsonConverterFactory());
            options.Converters.Add(new SortOrderJsonConverter());
{%- for class in outline.classes %}
    {%- if class.kind.is_any_kind_of_enum() %}
            options.Converters.Add(new {{ class.name() }}JsonConverter());
    {%- endif %}
{%- endfor %}
            return options;
        }
        static public string Serialize<T>(T value) {
            return JsonSerializer.Serialize(value, options());
        }
        static public T? Deserialize<T>(string value) {
            return JsonSerializer.Deserialize<T>(value, options());
        }
    }

    {%- for delegate in outline.delegates %}
        public class {{ delegate.model_name }}Delegate : Delegate {
            readonly string? _Token;
            protected internal {{ delegate.model_name }}Delegate(string? token = null) {
                _Token = token;
            }
    {%- for action in delegate.actions %}
            public async Task<{{ action.response }}> {{ action.name|capitalize_first }}({{ delegate.model_name }}{{ action.name|capitalize_first }}Args args) {
                return await Request<{{ action.response }}>("{{ delegate.model_name }}", "{{ action.name }}", args, _Token);
            }
    {%- endfor %}
        }
    {%- endfor %}

    public class Delegate {

        protected static readonly string HOST = "{{ conf.host }}";

        protected async Task<T> Request<T>(string model, string action, object args, string? token = null) {
            // not handle our own errors yet
            var uri = new Uri(HOST + "/" + model + "/action/" + action);
            var client = new HttpClient();
            if (token != null) {
                client.DefaultRequestHeaders.Add("Authorization", $"Bearer {token}");
            }
            var jsonContent = JSJsonSerializer.Serialize(args)!;
            var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");
            var response = await client.PostAsync(uri, content);
            var httpResponseBody = await response.Content.ReadAsStringAsync();
            if (((int)response.StatusCode) >= 400) {
                throw new TeoException(JSJsonSerializer.Deserialize<ResponseError>(httpResponseBody)!);
            }
            return JSJsonSerializer.Deserialize<T>(httpResponseBody)!;
        }
    }
}
